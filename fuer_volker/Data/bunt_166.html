<!doctype html>
<html>
    <head>
        <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.7.45" />
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
        <title>3D Boxes Viewer</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                display: block;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);
            const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            // Define your boxes: [minX, minY, minZ, maxX, maxY, maxZ, color]
            const boxesData = [
                [-1.5, -1.5, -2.5, 0.5, 0.5, -0.5, 0xff0000],
[-2.5, -3.5, -1.5, -0.5, -1.5, -0.5, 0xff0000],
[-0.5, -0.5, -4.5, 0.5, 1.5, -2.5, 0xff0000],
[-1.5, -2.5, 0.5, 0.5, -0.5, 2.5, 0x800080],
[-0.5, -1.5, 2.5, 0.5, 0.5, 4.5, 0x800080],
[-2.5, -3.5, -0.5, -0.5, -1.5, 0.5, 0x800080],
[0.5, -2.5, 0.5, 2.5, -0.5, 2.5, 0x0000ff],
[-0.5, -0.5, 0.5, 1.5, 1.5, 1.5, 0x0000ff],
[0.5, -1.5, 2.5, 1.5, 0.5, 4.5, 0x0000ff],
[0.5, 1.5, 0.5, 2.5, 3.5, 2.5, 0xffa500],
[-0.5, 1.5, -1.5, 1.5, 2.5, 0.5, 0xffa500],
[-0.5, -0.5, 1.5, 1.5, 1.5, 2.5, 0xffa500],
[0.5, 1.5, -3.5, 2.5, 3.5, -1.5, 0x008000],
[0.5, -0.5, -4.5, 1.5, 1.5, -2.5, 0x008000],
[-0.5, 2.5, -1.5, 1.5, 3.5, 0.5, 0x008000]
                //[0, 0, 0, 2, 2, 2, 0xff0000],  // red 2x2x2
                //[-3.0, -3.0, -3.0, -1.0, -1.0, -1.0, 0x0000ff],
                //[-3.0, -1.0, -2.0, -2.0, 1.0, 0.0, 0x0000ff],
            ];
            // Create boxes
            boxesData.forEach((data) => {
                const [minX, minY, minZ, maxX, maxY, maxZ, color] = data;
                const width = maxX - minX;
                const height = maxY - minY;
                const depth = maxZ - minZ;
                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshLambertMaterial({
                    color: color,
                    flatShading: true,
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1,
                });
                const box = new THREE.Mesh(geometry, material);
                // Position at center of the box
                box.position.set(minX + width / 2, minY + height / 2, minZ + depth / 2);
                scene.add(box);
                // Add edges for better visibility
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
                );
                line.position.copy(box.position);
                scene.add(line);
            });
            // Mouse and touch rotation controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };
            // Mouse events (desktop)
            renderer.domElement.addEventListener("mousedown", (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });
            renderer.domElement.addEventListener("mousemove", (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    rotation.y += deltaX * 0.01;
                    rotation.x += deltaY * 0.01;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });
            renderer.domElement.addEventListener("mouseup", () => {
                isDragging = false;
            });
            // Touch events (mobile)
            renderer.domElement.addEventListener("touchstart", (e) => {
                if (e.touches.length === 1) {
                    isDragging = true;
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                }
            });
            renderer.domElement.addEventListener("touchmove", (e) => {
                if (isDragging && e.touches.length === 1) {
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - previousMousePosition.x;
                    const deltaY = e.touches[0].clientY - previousMousePosition.y;
                    rotation.y += deltaX * 0.01;
                    rotation.x += deltaY * 0.01;
                    previousMousePosition = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                }
            }, { passive: false });
            renderer.domElement.addEventListener("touchend", () => {
                isDragging = false;
            });
            // Mouse wheel zoom (desktop)
            renderer.domElement.addEventListener("wheel", (e) => {
                e.preventDefault();
                camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            });
            // Pinch-to-zoom for mobile
            let initialPinchDistance = 0;
            renderer.domElement.addEventListener("touchstart", (e) => {
                if (e.touches.length === 2) {
                    isDragging = false;
                    initialPinchDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                }
            });
            renderer.domElement.addEventListener("touchmove", (e) => {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const delta = currentDistance - initialPinchDistance;
                    camera.position.multiplyScalar(1 - delta * 0.001);
                    initialPinchDistance = currentDistance;
                }
            }, { passive: false });
            // Handle window resize
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                // Apply rotation to entire scene
                scene.rotation.x = rotation.x;
                scene.rotation.y = rotation.y;
                renderer.render(scene, camera);
            }
            animate();
        </script>
    </body>
</html>
