<!doctype html>
<html>
    <head>
        <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.7.45" />
        <meta charset="utf-8" />
        <title>3D Boxes Viewer</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
            }
            canvas {
                display: block;
            }
        </style>
    </head>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Define your boxes: [minX, minY, minZ, maxX, maxY, maxZ, color]
            const boxesData = [
                [-3.0, -3.5, -1.5, -1.0, -1.5, 0.5, 0x0000ff],
[-2.0, -2.5, -3.5, -1.0, -0.5, -1.5, 0x0000ff],
[-2.0, -1.5, -0.5, 0.0, 0.5, 0.5, 0x0000ff],
[-3.0, -0.5, -2.5, -1.0, 1.5, -0.5, 0xff0000],
[-1.0, 0.5, -1.5, 1.0, 2.5, -0.5, 0xff0000],
[-3.0, -2.5, -3.5, -2.0, -0.5, -1.5, 0xff0000],
[-1.0, -3.5, 0.5, 1.0, -1.5, 2.5, 0x008000],
[-2.0, -1.5, 0.5, 0.0, 0.5, 1.5, 0x008000],
[1.0, -3.5, -0.5, 3.0, -2.5, 1.5, 0x008000],
[1.0, 1.5, -0.5, 3.0, 3.5, 1.5, 0xffa500],
[-1.0, 0.5, -0.5, 1.0, 2.5, 0.5, 0xffa500],
[1.0, 0.5, 1.5, 2.0, 2.5, 3.5, 0xffa500],
[0.0, -1.5, 0.5, 2.0, 0.5, 2.5, 0x800080],
[0.0, 0.5, 1.5, 1.0, 2.5, 3.5, 0x800080],
[1.0, -2.5, -0.5, 3.0, -1.5, 1.5, 0x800080]
                //[0, 0, 0, 2, 2, 2, 0xff0000],  // red 2x2x2
                //[-3.0, -3.0, -3.0, -1.0, -1.0, -1.0, 0x0000ff],
                //[-3.0, -1.0, -2.0, -2.0, 1.0, 0.0, 0x0000ff],
            ];

            // Create boxes
            boxesData.forEach((data) => {
                const [minX, minY, minZ, maxX, maxY, maxZ, color] = data;

                const width = maxX - minX;
                const height = maxY - minY;
                const depth = maxZ - minZ;

                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshLambertMaterial({
                    color: color,
                    flatShading: true, // This gives flat shading!
                    polygonOffset: true,
                    polygonOffsetFactor: 1,
                    polygonOffsetUnits: 1,
                });

                const box = new THREE.Mesh(geometry, material);

                // Position at center of the box
                box.position.set(minX + width / 2, minY + height / 2, minZ + depth / 2);

                scene.add(box);

                // Add edges for better visibility
                const edges = new THREE.EdgesGeometry(geometry);
                const line = new THREE.LineSegments(
                    edges,
                    new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 })
                );
                line.position.copy(box.position);
                scene.add(line);
            });

            // Mouse rotation controls
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotation = { x: 0, y: 0 };

            renderer.domElement.addEventListener("mousedown", (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener("mousemove", (e) => {
                if (isDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    rotation.y += deltaX * 0.01;
                    rotation.x += deltaY * 0.01;

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener("mouseup", () => {
                isDragging = false;
            });

            // Mouse wheel zoom
            renderer.domElement.addEventListener("wheel", (e) => {
                e.preventDefault();
                camera.position.multiplyScalar(1 + e.deltaY * 0.001);
            });

            // Handle window resize
            window.addEventListener("resize", () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);

                // Apply rotation to entire scene
                scene.rotation.x = rotation.x;
                scene.rotation.y = rotation.y;

                renderer.render(scene, camera);
            }

            animate();
        </script>
    </body>
</html>
