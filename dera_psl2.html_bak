<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Verification script</title>
    <!--<link rel="stylesheet" type="text/css" href="pm.css">-->
    <link href="themes/prism.css" rel="stylesheet" />
    <script src="https://sagecell.sagemath.org/static/embedded_sagecell.js"></script>
<script>sagecell.makeSagecell({"inputLocation": ".sage"});</script>
</head>
<body>
<h3>Verification script for the paper <em>Transitive sets of derangements in primitive actions of PSL<sub>2</sub>(q)</em></h3>
<p>This page provides the SageMath script which confirms the
  computational parts of the arXiv preprint <a href="https://arxiv.org/abs/2512.19500/">Transitive sets of derangements in primitive actions of PSL<sub>2</sub>(q)</a>. You can</p>
  <ul>
    <li> Download the SageMath
      script <a href="Code/dera_psl2.sage">dera_psl2.sage</a></li>
    <li> Run and view the code in <a href="https://sagecell.sagemath.org/">SageCell</a>. To do so, just click the <b>Evaluate</b> button below:
      <div class="sage">
  <script type="text/x-sage">from itertools import product

# Corollary 3.3
for q in [z for z in range(5, 21, 2) if is_prime_power(z)]:
    F = GF(q)
    S = {r + 1/r for r in F if r != 0}
    S.add(F.zero())
    for a, b, c, d in product(F, repeat=4):
        if a*d - b*c == 1:
            if all(a*r + d/r in S and -c*r + b/r in S for r in F if r != 0):
                assert ((a == d == 0 or b == c == 0) or
                        (q == 9 and F(2) in {a*r + d/r for r in F if r != 0}))
print('Corollary 3.3 confirmed')

# Corollary 3.6
for q in [z for z in range(3, 21, 2) if is_prime_power(z)]:
    F = GF(q^2)
    S = {r + 1/r for r in F if r^(q+1) == 1}
    S.add(F.zero())
    for a, b in product(F, repeat=2):
        if a^(q+1) + b^(q+1) == 1:
            if all(a*r + a^(q+1)/r in S and b*r + b^(q+1)/r in S for
                   r in F if r^(q+1) == 1):
                assert a == 0 or b == 0
print('Corollary 3.6 confirmed')

def gener(L):
    # Compute matrix group generated by the matrices in L
    S = {matrix(z, immutable=True) for z in L}
    flag = True
    while flag:
        C = S.copy()
        flag = False
        for x in L:
            for y in S:
                xy = matrix(x*y, immutable=True)
                if xy not in C:
                    C.add(xy)
                    flag = True
        S = C.copy()
    return S

catal = [1, 2, 5, 14, 42]

# Hbar = A_4 (Case (d))
F.<i> = QuadraticField(-1)
S.<a, b, c, d, A, B, C, D> = F[]
I = matrix(S, 2, [i, 0, 0, -i])
J = matrix(S, 2, [0, 1, -1, 0])
K = I*J
W = (-matrix.identity(S, 2) + I + J + K)/2
H = gener([I, W])
x = matrix(2, [a, b, c, d])
y = matrix(2, [A, B, C, D])
T = {z.trace() for z in H} - {-2, 2}
assert prod(A - t for t in T) == A^3 - A
txy = x.trace()*y.trace() - (x*y).trace()
det = x.det()
for m in [0, 1]:
    s = sum((h*y).trace()*(h*x).trace()^(2*m+1) for h in H)
    assert 2*s == len(H)*catal[m]*txy*det^m
print('Case A_4 confirmed')

# Hbar = S_4 (Case (e))
N.<i> = QuadraticField(-1)
_x = N['dummy'].0
F.<rho> = NumberField(_x^2 - 2)
S.<a, b, c, d, A, B, C, D> = F[]
I = matrix(S, 2, [i, 0, 0, -i])
J = matrix(S, 2, [0, 1, -1, 0])
K = I*J
W = (-matrix.identity(S, 2) + I + J + K)/2
H = gener([(J + K)/rho, W])
x = matrix(2, [a, b, c, d])
y = matrix(2, [A, B, C, D])
T = {z.trace() for z in H} - {-2, 2}
assert prod(A - t for t in T) == A^5 + (-3)*A^3 + 2*A
txy = x.trace()*y.trace() - (x*y).trace()
det = x.det()
for m in [0, 1, 2]:
    s = sum((h*y).trace()*(h*x).trace()^(2*m+1) for h in H)
    assert 2*s == len(H)*catal[m]*txy*det^m
print('Case S_4 confirmed')

# Hbar = A_5 (Case (f))
N.<i> = QuadraticField(-1)
_x = N['dummy'].0
F.<sig> = NumberField(_x^2 + _x - 1)
S.<a, b, c, d, A, B, C, D> = F[]
I = matrix(S, 2, [i, 0, 0, -i])
J = matrix(S, 2, [0, 1, -1, 0])
K = I*J
W = (-matrix.identity(S, 2) + I + J + K)/2
H = gener([I/2 + J*sig/2 + K*(sig+1)/2, W])
x = matrix(2, [a, b, c, d])
y = matrix(2, [A, B, C, D])
T = {z.trace() for z in H} - {-2, 2}
assert prod(A - t for t in T) == A^7 + (-4)*A^5 + 4*A^3 - A
txy = x.trace()*y.trace() - (x*y).trace()
det = x.det()
for m in [0, 1, 2, 3, 4]:
    s = sum((h*y).trace()*(h*x).trace()^(2*m+1) for h in H)
    assert 2*s == len(H)*catal[m]*txy*det^m
print('Case A_5 confirmed')
print('Finished, all claims confirmed!')
</script>
    </div></li>
    <li> Only view the code (copy and paste should work):
<pre><code class="language-python">from itertools import product

# Corollary 3.3
for q in [z for z in range(5, 21, 2) if is_prime_power(z)]:
    F = GF(q)
    S = {r + 1/r for r in F if r != 0}
    S.add(F.zero())
    for a, b, c, d in product(F, repeat=4):
        if a*d - b*c == 1:
            if all(a*r + d/r in S and -c*r + b/r in S for r in F if r != 0):
                assert ((a == d == 0 or b == c == 0) or
                        (q == 9 and F(2) in {a*r + d/r for r in F if r != 0}))
print(&#x27;Corollary 3.3 confirmed&#x27;)

# Corollary 3.6
for q in [z for z in range(3, 21, 2) if is_prime_power(z)]:
    F = GF(q^2)
    S = {r + 1/r for r in F if r^(q+1) == 1}
    S.add(F.zero())
    for a, b in product(F, repeat=2):
        if a^(q+1) + b^(q+1) == 1:
            if all(a*r + a^(q+1)/r in S and b*r + b^(q+1)/r in S for
                   r in F if r^(q+1) == 1):
                assert a == 0 or b == 0
print(&#x27;Corollary 3.6 confirmed&#x27;)

def gener(L):
    # Compute matrix group generated by the matrices in L
    S = {matrix(z, immutable=True) for z in L}
    flag = True
    while flag:
        C = S.copy()
        flag = False
        for x in L:
            for y in S:
                xy = matrix(x*y, immutable=True)
                if xy not in C:
                    C.add(xy)
                    flag = True
        S = C.copy()
    return S

catal = [1, 2, 5, 14, 42]

# Hbar = A_4 (Case (d))
F.&lt;i&gt; = QuadraticField(-1)
S.&lt;a, b, c, d, A, B, C, D&gt; = F[]
I = matrix(S, 2, [i, 0, 0, -i])
J = matrix(S, 2, [0, 1, -1, 0])
K = I*J
W = (-matrix.identity(S, 2) + I + J + K)/2
H = gener([I, W])
x = matrix(2, [a, b, c, d])
y = matrix(2, [A, B, C, D])
T = {z.trace() for z in H} - {-2, 2}
assert prod(A - t for t in T) == A^3 - A
txy = x.trace()*y.trace() - (x*y).trace()
det = x.det()
for m in [0, 1]:
    s = sum((h*y).trace()*(h*x).trace()^(2*m+1) for h in H)
    assert 2*s == len(H)*catal[m]*txy*det^m
print(&#x27;Case A_4 confirmed&#x27;)

# Hbar = S_4 (Case (e))
N.&lt;i&gt; = QuadraticField(-1)
_x = N[&#x27;dummy&#x27;].0
F.&lt;rho&gt; = NumberField(_x^2 - 2)
S.&lt;a, b, c, d, A, B, C, D&gt; = F[]
I = matrix(S, 2, [i, 0, 0, -i])
J = matrix(S, 2, [0, 1, -1, 0])
K = I*J
W = (-matrix.identity(S, 2) + I + J + K)/2
H = gener([(J + K)/rho, W])
x = matrix(2, [a, b, c, d])
y = matrix(2, [A, B, C, D])
T = {z.trace() for z in H} - {-2, 2}
assert prod(A - t for t in T) == A^5 + (-3)*A^3 + 2*A
txy = x.trace()*y.trace() - (x*y).trace()
det = x.det()
for m in [0, 1, 2]:
    s = sum((h*y).trace()*(h*x).trace()^(2*m+1) for h in H)
    assert 2*s == len(H)*catal[m]*txy*det^m
print(&#x27;Case S_4 confirmed&#x27;)

# Hbar = A_5 (Case (f))
N.&lt;i&gt; = QuadraticField(-1)
_x = N[&#x27;dummy&#x27;].0
F.&lt;sig&gt; = NumberField(_x^2 + _x - 1)
S.&lt;a, b, c, d, A, B, C, D&gt; = F[]
I = matrix(S, 2, [i, 0, 0, -i])
J = matrix(S, 2, [0, 1, -1, 0])
K = I*J
W = (-matrix.identity(S, 2) + I + J + K)/2
H = gener([I/2 + J*sig/2 + K*(sig+1)/2, W])
x = matrix(2, [a, b, c, d])
y = matrix(2, [A, B, C, D])
T = {z.trace() for z in H} - {-2, 2}
assert prod(A - t for t in T) == A^7 + (-4)*A^5 + 4*A^3 - A
txy = x.trace()*y.trace() - (x*y).trace()
det = x.det()
for m in [0, 1, 2, 3, 4]:
    s = sum((h*y).trace()*(h*x).trace()^(2*m+1) for h in H)
    assert 2*s == len(H)*catal[m]*txy*det^m
print(&#x27;Case A_5 confirmed&#x27;)
print(&#x27;Finished, all claims confirmed!&#x27;)</code></pre>
    </li>
  </ul>
  <p><a href="index.html">To start page</a></p>
  <script src="prism.js"></script>
</body>
</html>
